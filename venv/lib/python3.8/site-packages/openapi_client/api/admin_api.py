# coding: utf-8

"""
    NamSor API v2

    NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!   # noqa: E501

    OpenAPI spec version: 2.0.10
    Contact: contact@namsor.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient


class AdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_credits(self, api_key, usage_credits, user_message, **kwargs):  # noqa: E501
        """Add usage credits to an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credits(api_key, usage_credits, user_message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param int usage_credits: (required)
        :param str user_message: (required)
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_credits_with_http_info(api_key, usage_credits, user_message, **kwargs)  # noqa: E501
        else:
            (data) = self.add_credits_with_http_info(api_key, usage_credits, user_message, **kwargs)  # noqa: E501
            return data

    def add_credits_with_http_info(self, api_key, usage_credits, user_message, **kwargs):  # noqa: E501
        """Add usage credits to an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credits_with_http_info(api_key, usage_credits, user_message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param int usage_credits: (required)
        :param str user_message: (required)
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key', 'usage_credits', 'user_message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_credits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `add_credits`")  # noqa: E501
        # verify the required parameter 'usage_credits' is set
        if ('usage_credits' not in local_var_params or
                local_var_params['usage_credits'] is None):
            raise ValueError("Missing the required parameter `usage_credits` when calling `add_credits`")  # noqa: E501
        # verify the required parameter 'user_message' is set
        if ('user_message' not in local_var_params or
                local_var_params['user_message'] is None):
            raise ValueError("Missing the required parameter `user_message` when calling `add_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501
        if 'usage_credits' in local_var_params:
            path_params['usageCredits'] = local_var_params['usage_credits']  # noqa: E501
        if 'user_message' in local_var_params:
            path_params['userMessage'] = local_var_params['user_message']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/addCredits/{apiKey}/{usageCredits}/{userMessage}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemMetricsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def anonymize(self, source, anonymized, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize(source, anonymized, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.anonymize_with_http_info(source, anonymized, **kwargs)  # noqa: E501
        else:
            (data) = self.anonymize_with_http_info(source, anonymized, **kwargs)  # noqa: E501
            return data

    def anonymize_with_http_info(self, source, anonymized, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize_with_http_info(source, anonymized, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'anonymized']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method anonymize" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `anonymize`")  # noqa: E501
        # verify the required parameter 'anonymized' is set
        if ('anonymized' not in local_var_params or
                local_var_params['anonymized'] is None):
            raise ValueError("Missing the required parameter `anonymized` when calling `anonymize`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'anonymized' in local_var_params:
            path_params['anonymized'] = local_var_params['anonymized']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/anonymize/{source}/{anonymized}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_status(self, **kwargs):  # noqa: E501
        """Prints the current status of the classifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_status_with_http_info(self, **kwargs):  # noqa: E501
        """Prints the current status of the classifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history_aggregate(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_aggregate_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history_aggregate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistoryAggregate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_plans(self, **kwargs):  # noqa: E501
        """List all available plans in the default currency (usd).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_plans_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.available_plans_with_http_info(**kwargs)  # noqa: E501
            return data

    def available_plans_with_http_info(self, **kwargs):  # noqa: E501
        """List all available plans in the default currency (usd).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_plans" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/availablePlans', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_plans1(self, token, **kwargs):  # noqa: E501
        """List all available plans in the user's preferred currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans1(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_plans1_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.available_plans1_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def available_plans1_with_http_info(self, token, **kwargs):  # noqa: E501
        """List all available plans in the user's preferred currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans1_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_plans1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `available_plans1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/availablePlans/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_services(self, **kwargs):  # noqa: E501
        """List of API services and usage cost in Units (default is 1=ONE Unit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.available_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def available_services_with_http_info(self, **kwargs):  # noqa: E501
        """List of API services and usage cost in Units (default is 1=ONE Unit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_services" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiServices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_currencies(self, **kwargs):  # noqa: E501
        """List possible currency options for billing (USD, EUR, GBP, ...)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_currencies(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CurrenciesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_currencies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_currencies_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_currencies_with_http_info(self, **kwargs):  # noqa: E501
        """List possible currency options for billing (USD, EUR, GBP, ...)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_currencies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CurrenciesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_currencies" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingCurrencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrenciesOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_history(self, token, **kwargs):  # noqa: E501
        """Read the history billing information (invoices paid via Stripe or manually).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_history(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_history_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_history_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def billing_history_with_http_info(self, token, **kwargs):  # noqa: E501
        """Read the history billing information (invoices paid via Stripe or manually).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_history_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `billing_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingHistory/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingHistoryOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_info(self, token, **kwargs):  # noqa: E501
        """Read the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def billing_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Read the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `billing_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingInfoInOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def charge(self, **kwargs):  # noqa: E501
        """Create a Stripe Customer, based on a payment card token (from secure StripeJS) and email.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.charge(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InlineObject inline_object:
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.charge_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.charge_with_http_info(**kwargs)  # noqa: E501
            return data

    def charge_with_http_info(self, **kwargs):  # noqa: E501
        """Create a Stripe Customer, based on a payment card token (from secure StripeJS) and email.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.charge_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InlineObject inline_object:
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inline_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method charge" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'inline_object' in local_var_params:
            body_params = local_var_params['inline_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/charge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def corporate_key(self, api_key, corporate, **kwargs):  # noqa: E501
        """Setting an API Key to a corporate status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.corporate_key(api_key, corporate, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param bool corporate: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.corporate_key_with_http_info(api_key, corporate, **kwargs)  # noqa: E501
        else:
            (data) = self.corporate_key_with_http_info(api_key, corporate, **kwargs)  # noqa: E501
            return data

    def corporate_key_with_http_info(self, api_key, corporate, **kwargs):  # noqa: E501
        """Setting an API Key to a corporate status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.corporate_key_with_http_info(api_key, corporate, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param bool corporate: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key', 'corporate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method corporate_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `corporate_key`")  # noqa: E501
        # verify the required parameter 'corporate' is set
        if ('corporate' not in local_var_params or
                local_var_params['corporate'] is None):
            raise ValueError("Missing the required parameter `corporate` when calling `corporate_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501
        if 'corporate' in local_var_params:
            path_params['corporate'] = local_var_params['corporate']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/corporateKey/{apiKey}/{corporate}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def debug_level(self, logger, level, **kwargs):  # noqa: E501
        """Update debug level for a classifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.debug_level(logger, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logger: (required)
        :param str level: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.debug_level_with_http_info(logger, level, **kwargs)  # noqa: E501
        else:
            (data) = self.debug_level_with_http_info(logger, level, **kwargs)  # noqa: E501
            return data

    def debug_level_with_http_info(self, logger, level, **kwargs):  # noqa: E501
        """Update debug level for a classifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.debug_level_with_http_info(logger, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logger: (required)
        :param str level: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['logger', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method debug_level" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'logger' is set
        if ('logger' not in local_var_params or
                local_var_params['logger'] is None):
            raise ValueError("Missing the required parameter `logger` when calling `debug_level`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in local_var_params or
                local_var_params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `debug_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logger' in local_var_params:
            path_params['logger'] = local_var_params['logger']  # noqa: E501
        if 'level' in local_var_params:
            path_params['level'] = local_var_params['level']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/debugLevel/{logger}/{level}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def flush(self, **kwargs):  # noqa: E501
        """Flush counters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.flush(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.flush_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.flush_with_http_info(**kwargs)  # noqa: E501
            return data

    def flush_with_http_info(self, **kwargs):  # noqa: E501
        """Flush counters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.flush_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flush" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/flush', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invalidate_cache(self, **kwargs):  # noqa: E501
        """Invalidate system caches.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_cache(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.invalidate_cache_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.invalidate_cache_with_http_info(**kwargs)  # noqa: E501
            return data

    def invalidate_cache_with_http_info(self, **kwargs):  # noqa: E501
        """Invalidate system caches.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_cache_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invalidate_cache" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/invalidateCache', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def learnable(self, source, learnable, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable(source, learnable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool learnable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.learnable_with_http_info(source, learnable, **kwargs)  # noqa: E501
        else:
            (data) = self.learnable_with_http_info(source, learnable, **kwargs)  # noqa: E501
            return data

    def learnable_with_http_info(self, source, learnable, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable_with_http_info(source, learnable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool learnable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'learnable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method learnable" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `learnable`")  # noqa: E501
        # verify the required parameter 'learnable' is set
        if ('learnable' not in local_var_params or
                local_var_params['learnable'] is None):
            raise ValueError("Missing the required parameter `learnable` when calling `learnable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'learnable' in local_var_params:
            path_params['learnable'] = local_var_params['learnable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/learnable/{source}/{learnable}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def namsor_counter(self, **kwargs):  # noqa: E501
        """Get the overall API counter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.namsor_counter(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.namsor_counter_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.namsor_counter_with_http_info(**kwargs)  # noqa: E501
            return data

    def namsor_counter_with_http_info(self, **kwargs):  # noqa: E501
        """Get the overall API counter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.namsor_counter_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method namsor_counter" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/namsorCounter', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SoftwareVersionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def payment_info(self, token, **kwargs):  # noqa: E501
        """Get the Stripe payment information associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.payment_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.payment_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.payment_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def payment_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Get the Stripe payment information associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.payment_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method payment_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `payment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/paymentInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def procure_key(self, token, **kwargs):  # noqa: E501
        """Procure an API Key (sent via Email), based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.procure_key_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.procure_key_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def procure_key_with_http_info(self, token, **kwargs):  # noqa: E501
        """Procure an API Key (sent via Email), based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procure_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `procure_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/procureKey/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redeploy_ui(self, **kwargs):  # noqa: E501
        """Redeploy UI from current dev branch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeploy_ui(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.redeploy_ui_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.redeploy_ui_with_http_info(**kwargs)  # noqa: E501
            return data

    def redeploy_ui_with_http_info(self, **kwargs):  # noqa: E501
        """Redeploy UI from current dev branch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeploy_ui_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redeploy_ui" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/redeployUI', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redeploy_ui1(self, live, **kwargs):  # noqa: E501
        """Redeploy UI from current dev branch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeploy_ui1(live, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool live: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.redeploy_ui1_with_http_info(live, **kwargs)  # noqa: E501
        else:
            (data) = self.redeploy_ui1_with_http_info(live, **kwargs)  # noqa: E501
            return data

    def redeploy_ui1_with_http_info(self, live, **kwargs):  # noqa: E501
        """Redeploy UI from current dev branch.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeploy_ui1_with_http_info(live, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool live: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['live']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redeploy_ui1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'live' is set
        if ('live' not in local_var_params or
                local_var_params['live'] is None):
            raise ValueError("Missing the required parameter `live` when calling `redeploy_ui1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'live' in local_var_params:
            path_params['live'] = local_var_params['live']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/redeployUI/{live}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user_account(self, token, **kwargs):  # noqa: E501
        """Remove the user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_user_account_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_user_account_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def remove_user_account_with_http_info(self, token, **kwargs):  # noqa: E501
        """Remove the user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `remove_user_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/removeUserAccount/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user_account_on_behalf(self, api_key, **kwargs):  # noqa: E501
        """Remove (on behalf) a user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_on_behalf(api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_user_account_on_behalf_with_http_info(api_key, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_user_account_on_behalf_with_http_info(api_key, **kwargs)  # noqa: E501
            return data

    def remove_user_account_on_behalf_with_http_info(self, api_key, **kwargs):  # noqa: E501
        """Remove (on behalf) a user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_on_behalf_with_http_info(api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user_account_on_behalf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `remove_user_account_on_behalf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/removeUserAccountOnBehalf/{apiKey}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shutdown(self, **kwargs):  # noqa: E501
        """Stop learning and shutdown system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.shutdown_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shutdown_with_http_info(**kwargs)  # noqa: E501
            return data

    def shutdown_with_http_info(self, **kwargs):  # noqa: E501
        """Stop learning and shutdown system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/shutdown', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def software_version(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.software_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.software_version_with_http_info(**kwargs)  # noqa: E501
            return data

    def software_version_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method software_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/softwareVersion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SoftwareVersionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def source_stats(self, source, **kwargs):  # noqa: E501
        """Print basic source statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.source_stats(source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.source_stats_with_http_info(source, **kwargs)  # noqa: E501
        else:
            (data) = self.source_stats_with_http_info(source, **kwargs)  # noqa: E501
            return data

    def source_stats_with_http_info(self, source, **kwargs):  # noqa: E501
        """Print basic source statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.source_stats_with_http_info(source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method source_stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `source_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/sourceStats/{source}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemMetricsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats(self, **kwargs):  # noqa: E501
        """Print basic system statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def stats_with_http_info(self, **kwargs):  # noqa: E501
        """Print basic system statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemMetricsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stripe_connect(self, **kwargs):  # noqa: E501
        """Connects a Stripe Account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stripe_connect(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope:
        :param str code:
        :param str error:
        :param str error_description:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stripe_connect_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stripe_connect_with_http_info(**kwargs)  # noqa: E501
            return data

    def stripe_connect_with_http_info(self, **kwargs):  # noqa: E501
        """Connects a Stripe Account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stripe_connect_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope:
        :param str code:
        :param str error:
        :param str error_description:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['scope', 'code', 'error', 'error_description']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stripe_connect" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'scope' in local_var_params:
            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
        if 'code' in local_var_params:
            query_params.append(('code', local_var_params['code']))  # noqa: E501
        if 'error' in local_var_params:
            query_params.append(('error', local_var_params['error']))  # noqa: E501
        if 'error_description' in local_var_params:
            query_params.append(('error_description', local_var_params['error_description']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/stripeConnect', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_plan(self, plan_name, token, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan(plan_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_plan_with_http_info(plan_name, token, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_plan_with_http_info(plan_name, token, **kwargs)  # noqa: E501
            return data

    def subscribe_plan_with_http_info(self, plan_name, token, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_with_http_info(plan_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['plan_name', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_plan" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'plan_name' is set
        if ('plan_name' not in local_var_params or
                local_var_params['plan_name'] is None):
            raise ValueError("Missing the required parameter `plan_name` when calling `subscribe_plan`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `subscribe_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plan_name' in local_var_params:
            path_params['planName'] = local_var_params['plan_name']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/subscribePlan/{planName}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_plan_on_behalf(self, plan_name, api_key, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency (admin only).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_on_behalf(plan_name, api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, **kwargs)  # noqa: E501
            return data

    def subscribe_plan_on_behalf_with_http_info(self, plan_name, api_key, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency (admin only).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['plan_name', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_plan_on_behalf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'plan_name' is set
        if ('plan_name' not in local_var_params or
                local_var_params['plan_name'] is None):
            raise ValueError("Missing the required parameter `plan_name` when calling `subscribe_plan_on_behalf`")  # noqa: E501
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `subscribe_plan_on_behalf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plan_name' in local_var_params:
            path_params['planName'] = local_var_params['plan_name']  # noqa: E501
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/subscribePlanOnBehalf/{planName}/{apiKey}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def taxonomy_classes(self, classifier_name, **kwargs):  # noqa: E501
        """Print the taxonomy classes valid for the given classifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.taxonomy_classes(classifier_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str classifier_name: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.taxonomy_classes_with_http_info(classifier_name, **kwargs)  # noqa: E501
        else:
            (data) = self.taxonomy_classes_with_http_info(classifier_name, **kwargs)  # noqa: E501
            return data

    def taxonomy_classes_with_http_info(self, classifier_name, **kwargs):  # noqa: E501
        """Print the taxonomy classes valid for the given classifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.taxonomy_classes_with_http_info(classifier_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str classifier_name: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['classifier_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method taxonomy_classes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'classifier_name' is set
        if ('classifier_name' not in local_var_params or
                local_var_params['classifier_name'] is None):
            raise ValueError("Missing the required parameter `classifier_name` when calling `taxonomy_classes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'classifier_name' in local_var_params:
            path_params['classifierName'] = local_var_params['classifier_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/taxonomyClasses/{classifierName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_billing_info(self, token, **kwargs):  # noqa: E501
        """Sets or update the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_billing_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param BillingInfoInOut billing_info_in_out:
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_billing_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_billing_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def update_billing_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Sets or update the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_billing_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param BillingInfoInOut billing_info_in_out:
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token', 'billing_info_in_out']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_billing_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_billing_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'billing_info_in_out' in local_var_params:
            body_params = local_var_params['billing_info_in_out']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updateBillingInfo/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingInfoInOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_limit(self, usage_limit, hard_or_soft, token, **kwargs):  # noqa: E501
        """Modifies the hard/soft limit on the API plan's overages (default is 0$ soft limit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_limit(usage_limit, hard_or_soft, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int usage_limit: (required)
        :param bool hard_or_soft: (required)
        :param str token: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_limit_with_http_info(usage_limit, hard_or_soft, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_limit_with_http_info(usage_limit, hard_or_soft, token, **kwargs)  # noqa: E501
            return data

    def update_limit_with_http_info(self, usage_limit, hard_or_soft, token, **kwargs):  # noqa: E501
        """Modifies the hard/soft limit on the API plan's overages (default is 0$ soft limit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_limit_with_http_info(usage_limit, hard_or_soft, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int usage_limit: (required)
        :param bool hard_or_soft: (required)
        :param str token: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['usage_limit', 'hard_or_soft', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_limit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'usage_limit' is set
        if ('usage_limit' not in local_var_params or
                local_var_params['usage_limit'] is None):
            raise ValueError("Missing the required parameter `usage_limit` when calling `update_limit`")  # noqa: E501
        # verify the required parameter 'hard_or_soft' is set
        if ('hard_or_soft' not in local_var_params or
                local_var_params['hard_or_soft'] is None):
            raise ValueError("Missing the required parameter `hard_or_soft` when calling `update_limit`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'usage_limit' in local_var_params:
            path_params['usageLimit'] = local_var_params['usage_limit']  # noqa: E501
        if 'hard_or_soft' in local_var_params:
            path_params['hardOrSoft'] = local_var_params['hard_or_soft']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updateLimit/{usageLimit}/{hardOrSoft}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_payment_default(self, defaut_source_id, token, **kwargs):  # noqa: E501
        """Update the default Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_default(defaut_source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str defaut_source_id: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_payment_default_with_http_info(defaut_source_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_payment_default_with_http_info(defaut_source_id, token, **kwargs)  # noqa: E501
            return data

    def update_payment_default_with_http_info(self, defaut_source_id, token, **kwargs):  # noqa: E501
        """Update the default Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_default_with_http_info(defaut_source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str defaut_source_id: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['defaut_source_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payment_default" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'defaut_source_id' is set
        if ('defaut_source_id' not in local_var_params or
                local_var_params['defaut_source_id'] is None):
            raise ValueError("Missing the required parameter `defaut_source_id` when calling `update_payment_default`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_payment_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'defaut_source_id' in local_var_params:
            path_params['defautSourceId'] = local_var_params['defaut_source_id']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updatePaymentDefault/{defautSourceId}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_info(self, token, **kwargs):  # noqa: E501
        """Get the user profile associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.user_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def user_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Get the user profile associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/userInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_email(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_email(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_email_with_http_info(email_token, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_email_with_http_info(email_token, **kwargs)  # noqa: E501
            return data

    def verify_email_with_http_info(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_email_with_http_info(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_email" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_token' is set
        if ('email_token' not in local_var_params or
                local_var_params['email_token'] is None):
            raise ValueError("Missing the required parameter `email_token` when calling `verify_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_token' in local_var_params:
            path_params['emailToken'] = local_var_params['email_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/verifyEmail/{emailToken}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_remove_email(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_remove_email(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_remove_email_with_http_info(email_token, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_remove_email_with_http_info(email_token, **kwargs)  # noqa: E501
            return data

    def verify_remove_email_with_http_info(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_remove_email_with_http_info(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_remove_email" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_token' is set
        if ('email_token' not in local_var_params or
                local_var_params['email_token'] is None):
            raise ValueError("Missing the required parameter `email_token` when calling `verify_remove_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_token' in local_var_params:
            path_params['emailToken'] = local_var_params['email_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/verifyRemoveEmail/{emailToken}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def vet(self, source, vetted, **kwargs):  # noqa: E501
        """Vetting of a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vet(source, vetted, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool vetted: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.vet_with_http_info(source, vetted, **kwargs)  # noqa: E501
        else:
            (data) = self.vet_with_http_info(source, vetted, **kwargs)  # noqa: E501
            return data

    def vet_with_http_info(self, source, vetted, **kwargs):  # noqa: E501
        """Vetting of a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vet_with_http_info(source, vetted, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool vetted: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'vetted']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `vet`")  # noqa: E501
        # verify the required parameter 'vetted' is set
        if ('vetted' not in local_var_params or
                local_var_params['vetted'] is None):
            raise ValueError("Missing the required parameter `vetted` when calling `vet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'vetted' in local_var_params:
            path_params['vetted'] = local_var_params['vetted']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/vetting/{source}/{vetted}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
